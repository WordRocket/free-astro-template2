---
import BlogPost from '../../layouts/BlogPost.astro';
import { calculateReadingTime } from '../../lib/reading';
import { supabase } from '../../lib/supabase';
import { parseMarkdown } from '../../lib/markdown';

export async function getStaticPaths() {
	const { data: posts } = await supabase
		.from('posts')
		.select(`
			*,
			author:authors(name, slug),
			category:categories(name, slug),
			post_tags(tag:tags(name, slug))
		`)
		.eq('published', true);

	return (posts || []).map((post) => ({
		params: { slug: post.slug },
		props: { post },
	}));
}

const { post } = Astro.props;

const { data: allPosts } = await supabase
	.from('posts')
	.select('id, title, slug, published_at')
	.eq('published', true)
	.order('published_at', { ascending: false });

const sorted = allPosts || [];
const index = sorted.findIndex((p) => p.id === post.id);
const prev = index < sorted.length - 1 ? { id: sorted[index + 1].slug, title: sorted[index + 1].title } : null;
const next = index > 0 ? { id: sorted[index - 1].slug, title: sorted[index - 1].title } : null;

const readingTimeMin = calculateReadingTime(post.content || '');
const tags = post.post_tags?.map((pt: any) => pt.tag.name) || [];

const htmlContent = await parseMarkdown(post.content || '');

const blogPostData = {
	title: post.title,
	description: post.excerpt,
	pubDate: new Date(post.published_at),
	updatedDate: post.updated_at ? new Date(post.updated_at) : undefined,
	heroImage: post.hero_image,
	author: post.author?.name,
	category: post.category?.name,
	tags: tags,
};
---

<BlogPost {...blogPostData} prevPost={prev} nextPost={next} readingTimeMin={readingTimeMin}>
	<div class="prose prose-lg max-w-none dark:prose-invert" set:html={htmlContent} />
</BlogPost>
